<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layout Editor - AIDE RAP</title>
    <link rel="stylesheet" href="static/rap/diagram/layout-editor.css">
</head>
<body>
    <div class="toolbar">
        <h1 id="pageTitle">Layout Editor</h1>
        <label>Document:
            <select id="docSelect">
                <option value="">Loading...</option>
            </select>
        </label>
        <button id="viewLayout" class="secondary active">Layout</button>
        <label class="toggle-label">
            <input type="checkbox" id="fitToContent" checked>
            <span>Fit to content</span>
        </label>
        <div class="spacer"></div>
        <span class="help-text">Drag boxes to reposition</span>
        <a id="linkCompact" href="#" target="_blank" style="color: #aaa; font-size: 12px; display: none;">Compact</a>
        <a id="linkDetailed" href="#" target="_blank" style="color: #aaa; font-size: 12px; display: none;">Detailed</a>
        <a id="linkCardsPdf" href="#" target="_blank" style="color: #aaa; font-size: 12px; display: none;">Cards.pdf</a>
        <a id="linkCardsDocx" href="#" target="_blank" style="color: #aaa; font-size: 12px; display: none;">Cards.docx</a>
        <button id="saveBtn">Save</button>
        <button id="reloadModelBtn" class="secondary" style="display: none;">↻ Reload Model</button>
        <span class="status" id="status"></span>
        <a href="./" class="back-link" id="backLink">BACK</a>
    </div>
    <div class="canvas-container">
        <div class="canvas" id="canvas">
            <div class="loading">Select a document to edit its layout</div>
        </div>
    </div>

    <!-- Diagram modules -->
    <script src="static/rap/diagram/DiagramConstants.js"></script>
    <script src="static/rap/diagram/ConnectionCalculator.js"></script>
    <script src="static/rap/diagram/FlowIcons.js"></script>

    <script>
        // Create local references to shared modules (loaded via <script> tags above)
        const DiagramConstants = window.DiagramConstants;
        const ConnectionCalculator = window.ConnectionCalculator;
        const FlowIcons = window.FlowIcons;

        // Import constants from shared module
        const { BOX_WIDTH, BOX_HEIGHT_COMPACT, COMPACT_WIDTH, HEADER_HEIGHT, BOX_PADDING,
                STROKE_COLOR, STROKE_WIDTH, FONT_FAMILY, FONT_SIZE_CLASS, FONT_SIZE_ATTR, FONT_SIZE_COMPACT, FONT_SIZE_LABEL,
                OPTIONAL_DASH, READONLY_DASH, READONLY_COLOR, LABEL_UNDERLINE, LABEL2_UNDERLINE } = DiagramConstants;
        // ATTR_LINE_HEIGHT is dynamic — wider spacing for system diagrams
        const ATTR_LINE_HEIGHT_DEFAULT = DiagramConstants.ATTR_LINE_HEIGHT;
        let ATTR_LINE_HEIGHT = ATTR_LINE_HEIGHT_DEFAULT;

        /**
         * Escape text for use in XML/SVG.
         */
        function escapeXml(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        let currentDoc = null;
        let model = null;
        let layout = null;
        let showDetailed = true;
        let isDirty = false;
        let fitToContent = true;

        // Canvas for text measurement
        const measureCanvas = document.createElement('canvas');
        const measureCtx = measureCanvas.getContext('2d');

        // Measure text width using canvas
        function measureText(text, fontSize, fontFamily) {
            measureCtx.font = `${fontSize}px ${fontFamily}`;
            return measureCtx.measureText(text).width;
        }

        // Truncate text to fit within maxWidth, adding ellipsis if needed
        function truncateText(text, maxWidth, fontSize, fontFamily) {
            const textWidth = measureText(text, fontSize, fontFamily);
            if (textWidth <= maxWidth) return text;

            const ellipsis = '...';
            const ellipsisWidth = measureText(ellipsis, fontSize, fontFamily);
            const availableWidth = maxWidth - ellipsisWidth;

            // Binary search for max characters that fit
            let lo = 0, hi = text.length;
            while (hi - lo > 1) {
                const mid = Math.floor((lo + hi) / 2);
                if (measureText(text.substring(0, mid), fontSize, fontFamily) <= availableWidth) {
                    lo = mid;
                } else {
                    hi = mid;
                }
            }
            return text.substring(0, lo) + ellipsis;
        }

        // Word-wrap text into lines that fit within maxWidth
        function wrapText(text, maxWidth, fontSize, fontFamily) {
            const words = text.split(/\s+/).filter(Boolean);
            if (words.length === 0) return [];
            const lines = [];
            let currentLine = words[0];
            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' ' + words[i];
                if (measureText(testLine, fontSize, fontFamily) > maxWidth) {
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        /**
         * Compute per-attribute vertical slot layout.
         * For system diagrams: wraps flow names, variable slot heights.
         * For DataModel: uniform slot heights (ATTR_LINE_HEIGHT each).
         * @param {Array} attrs - Visible attributes array
         * @param {number} boxW - Box width for text wrapping
         * @param {boolean} wrap - Whether to wrap attribute names
         * @returns {{ centers: number[], slotHeights: number[], totalAttrHeight: number }}
         *   centers[i] = Y offset from attributes section start to slot center
         */
        // Space reserved for flow icons (format + transport): 2×12px icons + 2px gap + 4px margin
        const FLOW_ICON_SPACE = 30;
        // Flow names in system diagrams use a slightly larger font than DataModel attributes
        const FONT_SIZE_FLOW = 11;

        function getAttrYCenters(attrs, boxW, wrap) {
            // Reserve icon space if any attr has format/transport
            const hasIcons = wrap && attrs.some(a => a.format || a.transport);
            const iconReserve = hasIcons ? FLOW_ICON_SPACE : 0;
            const textWidth = boxW - 20 - iconReserve;
            const centers = [];
            const slotHeights = [];
            let cumY = 0;

            const fontSize = wrap ? FONT_SIZE_FLOW : FONT_SIZE_ATTR;
            for (const attr of attrs) {
                let slotH;
                if (wrap) {
                    const lines = wrapText(attr.name, textWidth, fontSize, FONT_FAMILY);
                    // Add vertical padding for multi-line entries so text doesn't touch the next slot
                    const padding = lines.length > 1 ? 8 : 0;
                    slotH = Math.max(lines.length * ATTR_LINE_HEIGHT_DEFAULT + padding, ATTR_LINE_HEIGHT);
                } else {
                    slotH = ATTR_LINE_HEIGHT;
                }
                centers.push(cumY + slotH / 2);
                slotHeights.push(slotH);
                cumY += slotH;
            }

            return { centers, slotHeights, totalAttrHeight: cumY };
        }

        // Calculate box width based on content
        function getBoxWidth(className) {
            const classDef = model.classes[className] || {};
            const nameWidth = measureText(className, FONT_SIZE_CLASS, FONT_FAMILY) + 20;
            const entityNames = Object.keys(model.classes);

            // Calculate what detailed mode width would be
            function calcDetailedWidth() {
                if (!fitToContent) return BOX_WIDTH;
                const attrs = getVisibleAttributes(className);
                let maxWidth = measureText(className, FONT_SIZE_CLASS, FONT_FAMILY);
                for (const attr of attrs) {
                    const attrText = ConnectionCalculator.formatAttribute(attr, entityNames);
                    maxWidth = Math.max(maxWidth, measureText(attrText, FONT_SIZE_ATTR, FONT_FAMILY));
                }
                return Math.max(BOX_WIDTH * 0.6, maxWidth + 20);
            }

            if (showDetailed) {
                // System diagrams: fixed width, flow names wrap (+icon space if needed)
                if (model.docType === 'systems') {
                    const attrs = (model.classes[className] || {}).attributes || [];
                    const hasIcons = attrs.some(a => a.format || a.transport);
                    return Math.max(nameWidth, COMPACT_WIDTH) + (hasIcons ? FLOW_ICON_SPACE : 0);
                }
                return calcDetailedWidth();
            }

            // Compact mode: fixed width, box height adapts to wrapped description
            return Math.max(nameWidth, COMPACT_WIDTH);
        }

        // DOM elements
        const docSelect = document.getElementById('docSelect');
        const canvas = document.getElementById('canvas');
        const saveBtn = document.getElementById('saveBtn');
        const reloadModelBtn = document.getElementById('reloadModelBtn');
        const statusEl = document.getElementById('status');
        const viewLayoutBtn = document.getElementById('viewLayout');
        const linkCompact = document.getElementById('linkCompact');
        const linkDetailed = document.getElementById('linkDetailed');
        const linkCardsPdf = document.getElementById('linkCardsPdf');
        const linkCardsDocx = document.getElementById('linkCardsDocx');

        // Calculate box height based on content
        function getBoxHeight(className) {
            const attrs = getVisibleAttributes(className);
            const isSystem = model.docType === 'systems';
            const w = getBoxWidth(className);
            const { totalAttrHeight } = getAttrYCenters(attrs, w, isSystem);
            const attrHeight = HEADER_HEIGHT + totalAttrHeight + BOX_PADDING;

            if (!showDetailed) {
                // Compact: height grows to fit wrapped description text
                const description = (model.classes[className] || {}).description || '';
                if (description) {
                    const textPadding = 20;
                    const lines = wrapText(description, w - textPadding, FONT_SIZE_COMPACT, FONT_FAMILY);
                    const descHeight = HEADER_HEIGHT + lines.length * ATTR_LINE_HEIGHT_DEFAULT + BOX_PADDING;
                    return Math.max(attrHeight, descHeight);
                }
            }
            return attrHeight;
        }

        // Get area color for a class
        function getColor(className) {
            const classDef = model.classes[className] || {};
            const area = classDef.area || '';
            const areaDef = model.areas[area] || {};
            return areaDef.color || '#FFFFFF';
        }

        // Build layout context for position-aware FK attribute ordering
        function buildLayoutContext() {
            const positions = (layout && layout.classes) || {};
            const entityCenterYs = {};
            for (const [name, pos] of Object.entries(positions)) {
                const attrCount = (model.classes[name]?.attributes || []).length;
                const h = HEADER_HEIGHT + attrCount * ATTR_LINE_HEIGHT + BOX_PADDING;
                entityCenterYs[name] = pos.y + h / 2;
            }
            return { positions, entityCenterYs, headerHeight: HEADER_HEIGHT, attrLineHeight: ATTR_LINE_HEIGHT };
        }

        // Get visible attributes, reordered to minimize FK line crossings
        function getVisibleAttributes(className) {
            const classDef = model.classes[className] || {};
            return ConnectionCalculator.getVisibleAttributes(classDef.attributes, className, buildLayoutContext());
        }

        // Load available documents
        async function loadDocuments() {
            try {
                const response = await fetch('api/layout-editor/documents');
                const docs = await response.json();
                docSelect.innerHTML = '<option value="">-- Select --</option>';
                docs.forEach(doc => {
                    const option = document.createElement('option');
                    option.value = doc;
                    option.textContent = doc;
                    docSelect.appendChild(option);
                });

                // Check URL parameter or auto-load if only one document
                const urlParams = new URLSearchParams(window.location.search);
                const docParam = urlParams.get('doc');
                if (docParam && docs.includes(docParam)) {
                    docSelect.value = docParam;
                    loadDocument(docParam);
                } else if (docs.length === 1) {
                    // Auto-load if only one document available
                    docSelect.value = docs[0];
                    loadDocument(docs[0]);
                }
            } catch (e) {
                console.error('Failed to load documents:', e);
                docSelect.innerHTML = '<option value="">Error loading</option>';
            }
        }

        // Load document model and layout
        async function loadDocument(docName) {
            if (!docName) {
                canvas.innerHTML = '<div class="loading">Select a document to edit its layout</div>';
                return;
            }

            canvas.innerHTML = '<div class="loading">Loading...</div>';
            statusEl.textContent = '';

            try {
                const response = await fetch(`api/layout-editor/load?doc=${encodeURIComponent(docName)}`);
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to load');
                }

                currentDoc = docName;
                model = data.model;
                layout = data.layout;
                isDirty = false;

                // Adjust line height for system diagrams (wider spacing)
                ATTR_LINE_HEIGHT = (model.docType === 'systems')
                    ? DiagramConstants.ATTR_LINE_HEIGHT_SYSTEMS
                    : ATTR_LINE_HEIGHT_DEFAULT;
                // Update shared object so ConnectionCalculator picks it up
                DiagramConstants.ATTR_LINE_HEIGHT = ATTR_LINE_HEIGHT;


                // Update diagram links
                linkCompact.href = `docs-assets/layout/${docName}-diagram.svg`;
                linkDetailed.href = `docs-assets/layout/${docName}-diagram-detailed.svg`;
                linkCardsPdf.href = `docs-assets/layout/EntityCards.pdf`;
                linkCardsDocx.href = `docs-assets/layout/EntityCards.docx`;
                linkCompact.style.display = 'inline';
                linkDetailed.style.display = 'inline';
                linkCardsPdf.style.display = 'inline';
                linkCardsDocx.style.display = 'inline';

                renderCanvas();

                // Check for model changes after loading
                await checkForModelChanges();
            } catch (e) {
                console.error('Failed to load document:', e);
                canvas.innerHTML = `<div class="loading">Error: ${e.message}</div>`;
            }
        }

        /**
         * Check if the data model has changed since server startup.
         * Shows a dialog if changes are detected.
         */
        async function checkForModelChanges() {
            try {
                const resp = await fetch('api/schema/check-changes');
                const { changed } = await resp.json();

                if (changed) {
                    // Show reload button
                    reloadModelBtn.style.display = 'inline-block';
                    reloadModelBtn.classList.add('highlight');

                    // Alert user
                    const reload = confirm(
                        'Das Datenmodell hat sich geändert.\n\n' +
                        'Möchten Sie das Modell neu laden?\n' +
                        '(Alternativ: "↻ Reload Model" Button verwenden)'
                    );

                    if (reload) {
                        await reloadModel();
                    }
                } else {
                    reloadModelBtn.style.display = 'none';
                }
            } catch (e) {
                console.warn('Could not check for model changes:', e);
            }
        }

        /**
         * Reload the schema from markdown files and refresh the editor.
         */
        async function reloadModel() {
            statusEl.textContent = 'Reloading model...';
            try {
                const resp = await fetch('api/schema/reload', { method: 'POST' });
                const result = await resp.json();

                if (!result.success) {
                    throw new Error(result.error || 'Reload failed');
                }

                // Reload current document to get fresh model
                if (currentDoc) {
                    await loadDocument(currentDoc);
                }

                reloadModelBtn.style.display = 'none';
                reloadModelBtn.classList.remove('highlight');
                statusEl.textContent = 'Model reloaded';
                setTimeout(() => { if (!isDirty) statusEl.textContent = ''; }, 2000);
            } catch (e) {
                console.error('Model reload failed:', e);
                statusEl.textContent = 'Error: ' + e.message;
            }
        }

        // Render all class boxes on canvas
        function renderCanvas() {
            if (!model || !layout) return;

            const positions = layout.classes || {};

            // Calculate canvas size to fit all entities
            let maxX = 400;
            let maxY = 300;

            for (const className of Object.keys(model.classes)) {
                const pos = positions[className] || { x: 50, y: 50 };
                const height = getBoxHeight(className);
                const width = getBoxWidth(className);
                maxX = Math.max(maxX, pos.x + width + 50);
                maxY = Math.max(maxY, pos.y + height + 50);
            }

            // Update layout canvas size
            if (!layout.canvas) layout.canvas = {};
            layout.canvas.width = maxX;
            layout.canvas.height = maxY;

            canvas.style.width = maxX + 'px';
            canvas.style.height = maxY + 'px';
            canvas.innerHTML = '';

            // Create SVG layer for connections
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('connections-layer');
            svg.setAttribute('width', maxX);
            svg.setAttribute('height', maxY);
            canvas.appendChild(svg);

            // Create class boxes
            for (const [className, classDef] of Object.entries(model.classes)) {
                const pos = positions[className] || { x: 50, y: 50 };
                const box = createClassBox(className, classDef, pos);
                canvas.appendChild(box);
            }

            // Draw connection lines
            drawConnections(svg, positions);
        }

        // Compute absolute attrY for system diagrams (wrapped slots), or undefined for DataModel
        function computeAttrY(className, attrIdx, positions) {
            if (model.docType !== 'systems') return undefined;
            const attrs = getVisibleAttributes(className);
            const w = getBoxWidth(className);
            const { centers } = getAttrYCenters(attrs, w, true);
            if (attrIdx >= centers.length) return undefined;
            const pos = positions[className] || { x: 50, y: 50 };
            return pos.y + HEADER_HEIGHT + BOX_PADDING / 2 + centers[attrIdx];
        }

        // Get connection points for a relationship (using shared module)
        function getConnectionPoint(fromClass, toClass, attrIndex, positions) {
            const fromPos = positions[fromClass] || { x: 50, y: 50 };
            const toPos = positions[toClass] || { x: 50, y: 50 };
            const fromHeight = getBoxHeight(fromClass);
            const toHeight = getBoxHeight(toClass);
            const fromWidth = getBoxWidth(fromClass);
            const toWidth = getBoxWidth(toClass);
            const attrY = computeAttrY(fromClass, attrIndex, positions);

            return ConnectionCalculator.getConnectionPoint(
                fromPos, toPos, fromHeight, toHeight, attrIndex, showDetailed, fromWidth, toWidth, attrY
            );
        }

        // Draw lines between related entities
        function drawConnections(svg, positions) {
            if (!model || !model.classes) return;

            // Add arrowhead marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
                </marker>
            `;
            svg.appendChild(defs);

            const entityNames = Object.keys(model.classes);

            // Helper: draw a single connection path
            function drawConnectionPath(svg, fromClass, toClass, attrIdx, attr, positions) {
                const fromPos = positions[fromClass] || { x: 50, y: 50 };
                const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathEl.setAttribute('fill', 'none');
                pathEl.setAttribute('stroke', DiagramConstants.STROKE_COLOR);
                pathEl.setAttribute('stroke-width', '1');
                pathEl.setAttribute('marker-end', 'url(#arrowhead)');

                if (attr.ui?.readonly) {
                    pathEl.setAttribute('stroke-dasharray', READONLY_DASH);
                } else if (attr.optional) {
                    pathEl.setAttribute('stroke-dasharray', OPTIONAL_DASH);
                }

                let pathD;
                if (fromClass === toClass) {
                    const bw = getBoxWidth(fromClass);
                    const bh = getBoxHeight(fromClass);
                    const selfAttrY = computeAttrY(fromClass, attrIdx, positions);
                    const arc = ConnectionCalculator.getSelfReferenceArc(fromPos, bw, bh, attrIdx, selfAttrY);
                    pathD = ConnectionCalculator.getSelfReferenceArcPath(arc);
                } else {
                    const conn = getConnectionPoint(fromClass, toClass, attrIdx, positions);
                    pathD = ConnectionCalculator.getNormalConnectionPath(conn);
                }

                pathEl.setAttribute('d', pathD);
                svg.appendChild(pathEl);
            }

            if (model.relationships && model.relationships.length > 0) {
                // Use explicit relationships (supports multi-receiver flows)
                for (const rel of model.relationships) {
                    if (!model.classes[rel.from] || !model.classes[rel.to]) continue;
                    const attrs = getVisibleAttributes(rel.from);
                    const attrIdx = attrs.findIndex(a => a.name === rel.displayName);
                    if (attrIdx < 0) continue;
                    drawConnectionPath(svg, rel.from, rel.to, attrIdx, attrs[attrIdx], positions);
                }
            } else {
                // Fallback: scan attributes for type matching (legacy models without relationships)
                for (const className of entityNames) {
                    const attrs = getVisibleAttributes(className);
                    for (let i = 0; i < attrs.length; i++) {
                        const baseType = ConnectionCalculator.extractBaseType(attrs[i].type);
                        if (entityNames.includes(baseType)) {
                            drawConnectionPath(svg, className, baseType, i, attrs[i], positions);
                        }
                    }
                }
            }
        }

        /**
         * Generate complete SVG string for export.
         * @param {boolean} detailed - Whether to show attributes
         * @returns {string} Complete SVG document
         */
        function generateSVG(detailed) {
            if (!model || !layout) return '';

            const positions = layout.classes || {};
            const entityNames = Object.keys(model.classes);
            const layoutCtx = buildLayoutContext();

            const isSystem = model.docType === 'systems';

            // Helper to get box width for a class (matches getBoxWidth logic)
            function boxWidth(className) {
                const classDef = model.classes[className] || {};
                const nameWidth = measureText(className, FONT_SIZE_CLASS, FONT_FAMILY) + 20;

                if (!detailed) {
                    // Compact mode: fixed width, height adapts to wrapped description
                    return Math.max(nameWidth, COMPACT_WIDTH);
                }

                // System diagrams: fixed width, flow names wrap (+icon space if needed)
                if (isSystem) {
                    const attrs = (model.classes[className] || {}).attributes || [];
                    const hasIcons = attrs.some(a => a.format || a.transport);
                    return Math.max(nameWidth, COMPACT_WIDTH) + (hasIcons ? FLOW_ICON_SPACE : 0);
                }

                // Detailed mode width for DataModel
                if (!fitToContent) return BOX_WIDTH;
                const attrs = ConnectionCalculator.getVisibleAttributes(
                    (model.classes[className] || {}).attributes, className, layoutCtx
                );
                let maxWidth = measureText(className, FONT_SIZE_CLASS, FONT_FAMILY);
                for (const attr of attrs) {
                    const attrText = ConnectionCalculator.formatAttribute(attr, entityNames);
                    maxWidth = Math.max(maxWidth, measureText(attrText, FONT_SIZE_ATTR, FONT_FAMILY));
                }
                return Math.max(BOX_WIDTH * 0.6, maxWidth + 20);
            }

            // Helper to get visible attrs for a class
            function svgAttrs(className) {
                return ConnectionCalculator.getVisibleAttributes(
                    (model.classes[className] || {}).attributes, className, layoutCtx
                );
            }

            // Helper to get box height for a class
            function boxHeight(className) {
                const attrs = svgAttrs(className);
                const w = boxWidth(className);
                const { totalAttrHeight } = getAttrYCenters(attrs, w, isSystem);
                const attrHeight = HEADER_HEIGHT + totalAttrHeight + BOX_PADDING;

                if (!detailed) {
                    // Compact: height grows to fit wrapped description text
                    const description = (model.classes[className] || {}).description || '';
                    if (description) {
                        const textPadding = 20;
                        const lines = wrapText(description, w - textPadding, FONT_SIZE_COMPACT, FONT_FAMILY);
                        const descHeight = HEADER_HEIGHT + lines.length * ATTR_LINE_HEIGHT_DEFAULT + BOX_PADDING;
                        return Math.max(attrHeight, descHeight);
                    }
                }
                return attrHeight;
            }

            // Pre-compute widths for all entities
            const widths = {};
            for (const className of entityNames) {
                widths[className] = boxWidth(className);
            }

            // Calculate canvas dimensions
            let maxX = 400, entitiesMaxY = 0;
            for (const className of entityNames) {
                const pos = positions[className] || { x: 50, y: 50 };
                maxX = Math.max(maxX, pos.x + widths[className] + 50);
                entitiesMaxY = Math.max(entitiesMaxY, pos.y + boxHeight(className));
            }

            // Calculate legend height
            // Left: areas, Right: type categories or icon legend (system diagrams)
            const numAreas = Object.keys(model.areas || {}).length;
            const globalTypesObj = model.globalTypes || {};
            const hasEnums = Object.values(globalTypesObj).some(t => t.kind === 'enum');
            const hasAggregates = Object.values(globalTypesObj).some(t => t.kind === 'aggregate');
            const hasPatterns = Object.values(globalTypesObj).some(t => t.kind === 'pattern');
            const numRightRows = isSystem
                ? 2  // format + transport icon rows
                : (hasEnums ? 1 : 0) + (hasAggregates ? 1 : 0) + (hasPatterns ? 1 : 0);
            const legendRows = Math.max(numAreas, numRightRows);
            const legendHeight = 30 + legendRows * 20 + 20; // header + rows + bottom padding

            const width = maxX;
            const height = entitiesMaxY + 40 + legendHeight; // 40px gap between entities and legend

            const parts = [
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">`,
                '  <defs>',
                '    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">',
                '      <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>',
                '    </marker>'
            ];

            // ClipPath defs for header background clipping (rounded box corners)
            for (const className of entityNames) {
                if (!(className in positions)) continue;
                const pos = positions[className];
                const h = boxHeight(className);
                const w = widths[className];
                parts.push(`    <clipPath id="clip-${escapeXml(className)}"><rect x="${pos.x}" y="${pos.y}" width="${w}" height="${h}" rx="3"/></clipPath>`);
            }

            parts.push('  </defs>');
            parts.push(`  <rect width="${width}" height="${height}" fill="white"/>`);
            parts.push('');
            parts.push('  <!-- Relationships -->');

            // Compute absolute attrY for system diagrams (wrapped slots)
            function svgAttrY(className, attrIdx) {
                if (!isSystem) return undefined;
                const attrs = svgAttrs(className);
                const w = widths[className];
                const { centers } = getAttrYCenters(attrs, w, true);
                if (attrIdx >= centers.length) return undefined;
                const pos = positions[className] || { x: 50, y: 50 };
                return pos.y + HEADER_HEIGHT + BOX_PADDING / 2 + centers[attrIdx];
            }

            // Helper: render a single SVG connection path
            function svgConnectionPath(fromClass, toClass, attrIdx, attr) {
                const fromPos = positions[fromClass] || { x: 50, y: 50 };
                const isOptional = attr.optional;
                const isReadonly = attr.ui?.readonly;
                const dashAttr = isReadonly
                    ? ` stroke-dasharray="${READONLY_DASH}"`
                    : (isOptional ? ` stroke-dasharray="${OPTIONAL_DASH}"` : '');
                const attrY = svgAttrY(fromClass, attrIdx);

                if (fromClass === toClass) {
                    const arc = ConnectionCalculator.getSelfReferenceArc(fromPos, widths[fromClass], boxHeight(fromClass), attrIdx, attrY);
                    const pathD = ConnectionCalculator.getSelfReferenceArcPath(arc);
                    parts.push(`  <path d="${pathD}" fill="none" stroke="${STROKE_COLOR}" stroke-width="1" marker-end="url(#arrowhead)"${dashAttr}/>`);
                } else {
                    const toPos = positions[toClass] || { x: 50, y: 50 };
                    const fromHeight = boxHeight(fromClass);
                    const toHeight = boxHeight(toClass);
                    const conn = ConnectionCalculator.getConnectionPoint(
                        fromPos, toPos, fromHeight, toHeight, attrIdx, detailed,
                        widths[fromClass], widths[toClass], attrY
                    );
                    const pathD = ConnectionCalculator.getNormalConnectionPath(conn);
                    parts.push(`  <path d="${pathD}" fill="none" stroke="${STROKE_COLOR}" stroke-width="1" marker-end="url(#arrowhead)"${dashAttr}/>`);
                }
            }

            // Render relationships
            if (model.relationships && model.relationships.length > 0) {
                for (const rel of model.relationships) {
                    if (!model.classes[rel.from] || !model.classes[rel.to]) continue;
                    const attrs = ConnectionCalculator.getVisibleAttributes(
                        (model.classes[rel.from] || {}).attributes, rel.from, layoutCtx
                    );
                    const attrIdx = attrs.findIndex(a => a.name === rel.displayName);
                    if (attrIdx < 0) continue;
                    svgConnectionPath(rel.from, rel.to, attrIdx, attrs[attrIdx]);
                }
            } else {
                for (const className of entityNames) {
                    const attrs = ConnectionCalculator.getVisibleAttributes(
                        (model.classes[className] || {}).attributes, className, layoutCtx
                    );
                    for (let i = 0; i < attrs.length; i++) {
                        const baseType = ConnectionCalculator.extractBaseType(attrs[i].type);
                        if (entityNames.includes(baseType)) {
                            svgConnectionPath(className, baseType, i, attrs[i]);
                        }
                    }
                }
            }

            parts.push('');
            parts.push('  <!-- Class boxes -->');

            // Render class boxes
            for (const className of entityNames) {
                if (!(className in positions)) continue;

                const pos = positions[className];
                const classDef = model.classes[className] || {};
                const color = getColor(className);
                const h = boxHeight(className);
                const w = widths[className];

                // White body + colored header (clipped to rounded box corners)
                parts.push(`  <rect x="${pos.x}" y="${pos.y}" width="${w}" height="${h}" fill="white" stroke="${STROKE_COLOR}" stroke-width="${STROKE_WIDTH}" rx="3"/>`);
                parts.push(`  <rect x="${pos.x}" y="${pos.y}" width="${w}" height="${HEADER_HEIGHT}" fill="${color}" clip-path="url(#clip-${escapeXml(className)})"/>`);


                // Class name (centered in header)
                const textY = pos.y + HEADER_HEIGHT / 2 + 4;
                parts.push(`  <text x="${pos.x + w / 2}" y="${textY}" text-anchor="middle" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_CLASS}" font-weight="bold">${escapeXml(className)}</text>`);

                // Separator line
                const sepY = pos.y + HEADER_HEIGHT;
                parts.push(`  <line x1="${pos.x}" y1="${sepY}" x2="${pos.x + w}" y2="${sepY}" stroke="${STROKE_COLOR}" stroke-width="1"/>`);

                if (detailed) {
                    // Detailed mode: attributes (FK attrs as bold name, others as name: type)
                    const visibleAttrs = svgAttrs(className);
                    const maxTextWidth = w - 10; // 5px padding on each side
                    const slotInfo = isSystem ? getAttrYCenters(visibleAttrs, w, true) : null;
                    let slotCumY = 0;
                    for (let i = 0; i < visibleAttrs.length; i++) {
                        const attr = visibleAttrs[i];
                        const cleanType = ConnectionCalculator.extractBaseType(attr.type);

                        // Determine styling based on schema ui flags
                        const isReadonly = attr.ui?.readonly;
                        const isLabel = attr.ui?.label && !attr.ui?.label2;
                        const isLabel2 = attr.ui?.label2;
                        const fillColor = isReadonly ? READONLY_COLOR : '#000';

                        if (isSystem && slotInfo) {
                            // System diagrams: wrap flow names within slot
                            const slotH = slotInfo.slotHeights[i];
                            const hasAttrIcons = attr.format || attr.transport;
                            const iconReserve = hasAttrIcons ? FLOW_ICON_SPACE : 0;
                            const wrappedLines = wrapText(attr.name, maxTextWidth - iconReserve, FONT_SIZE_FLOW, FONT_FAMILY);
                            const textBlockH = wrappedLines.length * ATTR_LINE_HEIGHT_DEFAULT;
                            const textStartY = sepY + BOX_PADDING / 2 + slotCumY + (slotH - textBlockH) / 2;

                            for (let j = 0; j < wrappedLines.length; j++) {
                                const lineY = textStartY + (j + 0.5) * ATTR_LINE_HEIGHT_DEFAULT + FONT_SIZE_FLOW * 0.35;
                                const weight = entityNames.includes(cleanType) ? ' font-weight="bold"' : '';
                                parts.push(`  <text x="${pos.x + 5}" y="${lineY}" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_FLOW}"${weight} fill="${fillColor}">${escapeXml(wrappedLines[j])}</text>`);
                            }

                            // Flow icons at right edge of box, vertically centered in slot
                            if (hasAttrIcons && FlowIcons) {
                                const slotCenterY = sepY + BOX_PADDING / 2 + slotCumY + slotH / 2;
                                let iconX = pos.x + w - 5; // right edge minus padding
                                if (attr.transport) {
                                    const markup = FlowIcons.toSVGMarkup(attr.transport, iconX - 12, slotCenterY - 6, 12);
                                    if (markup) { parts.push('  ' + markup); iconX -= 14; }
                                }
                                if (attr.format) {
                                    const markup = FlowIcons.toSVGMarkup(attr.format, iconX - 12, slotCenterY - 6, 12);
                                    if (markup) parts.push('  ' + markup);
                                }
                            }
                            slotCumY += slotH;
                        } else {
                            // DataModel: single-line attributes
                            const attrY = sepY + BOX_PADDING / 2 + (i + 0.5) * ATTR_LINE_HEIGHT + FONT_SIZE_ATTR * 0.35;
                            let displayText;
                            if (entityNames.includes(cleanType)) {
                                displayText = fitToContent ? attr.name : truncateText(attr.name, maxTextWidth, FONT_SIZE_ATTR, FONT_FAMILY);
                                parts.push(`  <text x="${pos.x + 5}" y="${attrY}" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_ATTR}" font-weight="bold" fill="${fillColor}">${escapeXml(displayText)}</text>`);
                            } else if (ConnectionCalculator.isAggregateType(cleanType)) {
                                const fullText = `«${attr.name}»`;
                                displayText = fitToContent ? fullText : truncateText(fullText, maxTextWidth, FONT_SIZE_ATTR, FONT_FAMILY);
                                parts.push(`  <text x="${pos.x + 5}" y="${attrY}" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_ATTR}" fill="${fillColor}">${escapeXml(displayText)}</text>`);
                            } else {
                                const fullText = `${attr.name}: ${cleanType}`;
                                displayText = fitToContent ? fullText : truncateText(fullText, maxTextWidth, FONT_SIZE_ATTR, FONT_FAMILY);
                                parts.push(`  <text x="${pos.x + 5}" y="${attrY}" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_ATTR}" fill="${fillColor}">${escapeXml(displayText)}</text>`);
                            }

                            // Add underline for LABEL/LABEL2 (DataModel only)
                            if (isLabel || isLabel2) {
                                const textWidth = measureText(displayText, FONT_SIZE_ATTR, FONT_FAMILY);
                                const underlineY = attrY + 2;
                                const dashAttr = isLabel2 ? ' stroke-dasharray="3,2"' : '';
                                parts.push(`  <line x1="${pos.x + 5}" y1="${underlineY}" x2="${pos.x + 5 + textWidth}" y2="${underlineY}" stroke="${fillColor}" stroke-width="1"${dashAttr}/>`);
                            }
                        }
                    }
                } else {
                    // Compact mode: word-wrapped description text (all lines shown, no truncation)
                    const description = classDef.description || '';
                    if (description) {
                        const textPadding = 5;
                        const lines = wrapText(description, w - textPadding * 2, FONT_SIZE_COMPACT, FONT_FAMILY);

                        for (let i = 0; i < lines.length; i++) {
                            const lineY = sepY + BOX_PADDING / 2 + (i + 0.5) * ATTR_LINE_HEIGHT_DEFAULT + FONT_SIZE_COMPACT * 0.35;
                            parts.push(`  <text x="${pos.x + textPadding}" y="${lineY}" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_COMPACT}" fill="#555">${escapeXml(lines[i])}</text>`);
                        }
                    }
                }
            }

            // Legend
            parts.push('');
            parts.push('  <!-- Legend -->');

            // Collect entity-local types with their area
            const typeToArea = {};  // typeName -> areaId
            for (const [className, classDef] of Object.entries(model.classes || {})) {
                if (classDef.types && Object.keys(classDef.types).length > 0) {
                    const area = classDef.area || 'unknown';
                    for (const typeName of Object.keys(classDef.types)) {
                        typeToArea[typeName] = area;
                    }
                }
            }

            // Get area color for a type (or gray for global)
            const getTypeColor = (typeName) => {
                const areaId = typeToArea[typeName];
                if (areaId && model.areas?.[areaId]) {
                    return model.areas[areaId].color || '#E0E0E0';
                }
                return '#E0E0E0';  // Gray for global types
            };

            // Group all types by kind (global + entity-local)
            const globalTypes = model.globalTypes || {};
            const aggregateTypes = [];
            const enumTypes = [];
            const patternTypes = [];

            // Add global types
            for (const [name, def] of Object.entries(globalTypes)) {
                if (def.kind === 'aggregate') aggregateTypes.push(name);
                else if (def.kind === 'enum') enumTypes.push(name);
                else if (def.kind === 'pattern') patternTypes.push(name);
            }

            // Add entity-local types
            for (const [className, classDef] of Object.entries(model.classes || {})) {
                if (classDef.types) {
                    for (const [typeName, typeDef] of Object.entries(classDef.types)) {
                        if (typeDef.kind === 'aggregate') aggregateTypes.push(typeName);
                        else if (typeDef.kind === 'enum') enumTypes.push(typeName);
                        else if (typeDef.kind === 'pattern') patternTypes.push(typeName);
                    }
                }
            }

            let legendX = 20;
            let legendY = entitiesMaxY + 50;
            const typesStartX = 160;
            const typeBoxHeight = 10;
            const typeSpacing = 5;

            // Headers
            parts.push(`  <text x="${legendX}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="12" font-weight="bold">Areas:</text>`);

            // Right column: Types for DataModel, Icons for System diagrams
            const areas = Object.entries(model.areas || {});

            if (isSystem && detailed) {
                // System diagrams: show format + transport icon legend
                parts.push(`  <text x="${typesStartX}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="12" font-weight="bold">Symbols:</text>`);
                legendY += 20;

                // Collect used format/transport keywords from all flows
                const usedFormats = new Set();
                const usedTransports = new Set();
                for (const classDef of Object.values(model.classes || {})) {
                    for (const attr of (classDef.attributes || [])) {
                        if (attr.format) usedFormats.add(attr.format.toUpperCase().trim());
                        if (attr.transport) usedTransports.add(attr.transport.toUpperCase().trim());
                    }
                }

                // Build icon rows: format first, then transport
                const iconRows = [];
                if (usedFormats.size > 0) iconRows.push({ label: 'Format', keywords: [...usedFormats] });
                if (usedTransports.size > 0) iconRows.push({ label: 'Transport', keywords: [...usedTransports] });

                const maxRows = Math.max(areas.length, iconRows.length);

                for (let row = 0; row < maxRows; row++) {
                    if (row < areas.length) {
                        const [areaId, areaDef] = areas[row];
                        const areaColor = areaDef.color || '#FFFFFF';
                        const areaName = areaDef.name || areaId;
                        parts.push(`  <rect x="${legendX}" y="${legendY - 10}" width="14" height="14" fill="${areaColor}" stroke="${STROKE_COLOR}" stroke-width="1"/>`);
                        parts.push(`  <text x="${legendX + 20}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="11">${escapeXml(areaName)}</text>`);
                    }

                    if (row < iconRows.length) {
                        const iconRow = iconRows[row];
                        parts.push(`  <text x="${typesStartX}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="10" font-weight="bold">${iconRow.label}:</text>`);
                        let iconX = typesStartX + measureText(iconRow.label + ':', 10, FONT_FAMILY) + 10;
                        for (const kw of iconRow.keywords) {
                            const markup = FlowIcons.toSVGMarkup(kw, iconX, legendY - 10, 12);
                            if (markup) {
                                parts.push('  ' + markup);
                                iconX += 14;
                            }
                            parts.push(`  <text x="${iconX}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="9">${escapeXml(kw)}</text>`);
                            iconX += measureText(kw, 9, FONT_FAMILY) + 8;
                        }
                    }

                    legendY += 20;
                }
            } else {
                // DataModel: show type categories (aggregates, enums, patterns)
                parts.push(`  <text x="${typesStartX}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="12" font-weight="bold">Types:</text>`);
                legendY += 20;

                const typeCategories = [];
                if (aggregateTypes.length > 0) typeCategories.push({ label: 'Aggregates', types: aggregateTypes });
                if (enumTypes.length > 0) typeCategories.push({ label: 'Enums', types: enumTypes });
                if (patternTypes.length > 0) typeCategories.push({ label: 'Patterns', types: patternTypes });

                const maxRows = Math.max(areas.length, typeCategories.length);

                for (let row = 0; row < maxRows; row++) {
                    if (row < areas.length) {
                        const [areaId, areaDef] = areas[row];
                        const areaColor = areaDef.color || '#FFFFFF';
                        const areaName = areaDef.name || areaId;
                        parts.push(`  <rect x="${legendX}" y="${legendY - 10}" width="14" height="14" fill="${areaColor}" stroke="${STROKE_COLOR}" stroke-width="1"/>`);
                        parts.push(`  <text x="${legendX + 20}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="11">${escapeXml(areaName)}</text>`);
                    }

                    if (row < typeCategories.length) {
                        const cat = typeCategories[row];
                        parts.push(`  <text x="${typesStartX}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="10" font-weight="bold">${cat.label}:</text>`);

                        let typeX = typesStartX + measureText(cat.label + ':', 10, FONT_FAMILY) + 8;
                        for (const typeName of cat.types) {
                            const textWidth = measureText(typeName, 9, FONT_FAMILY);
                            const typeColor = getTypeColor(typeName);
                            parts.push(`  <rect x="${typeX}" y="${legendY - 9}" width="${textWidth + 6}" height="${typeBoxHeight + 2}" fill="${typeColor}" stroke="${STROKE_COLOR}" stroke-width="0.5" rx="2"/>`);
                            parts.push(`  <text x="${typeX + 3}" y="${legendY - 1}" font-family="${FONT_FAMILY}" font-size="9">${escapeXml(typeName)}</text>`);
                            typeX += textWidth + 6 + typeSpacing;
                        }
                    }

                    legendY += 20;
                }
            }

            // Watermark in bottom right corner (aligned with legend start)
            parts.push('');
            parts.push('  <!-- Watermark -->');
            const wmX = width - 15;
            const wmYBase = entitiesMaxY + 50; // Same as legend start
            const today = new Date().toLocaleDateString('de-DE', { year: 'numeric', month: 'long', day: 'numeric' });
            parts.push(`  <text x="${wmX}" y="${wmYBase}" text-anchor="end" font-family="${FONT_FAMILY}" font-size="11" fill="#555">Artificial Intelligence for Development Engineers</text>`);
            parts.push(`  <text x="${wmX}" y="${wmYBase + 14}" text-anchor="end" font-family="${FONT_FAMILY}" font-size="11" fill="#555">Rapid Application Prototype <tspan fill="#0066cc">(http://github.com/aide-examples)</tspan></text>`);
            parts.push(`  <text x="${wmX}" y="${wmYBase + 28}" text-anchor="end" font-family="${FONT_FAMILY}" font-size="11" fill="#555">${today}</text>`);

            parts.push('</svg>');
            return parts.join('\n');
        }

        // Create a draggable class box element
        function createClassBox(className, classDef, pos) {
            const entityNames = Object.keys(model.classes);
            const box = document.createElement('div');
            box.className = 'class-box' + (showDetailed ? '' : ' compact') + (fitToContent ? ' fit-content' : '');
            box.dataset.className = className;
            box.style.left = pos.x + 'px';
            box.style.top = pos.y + 'px';
            box.style.height = getBoxHeight(className) + 'px';
            box.style.width = getBoxWidth(className) + 'px';

            // Header
            const header = document.createElement('div');
            header.className = 'header';
            header.textContent = className;
            header.style.backgroundColor = getColor(className);
            box.appendChild(header);

            if (showDetailed) {
                // Detailed view: attributes (FK attrs shown as bold name only)
                const attrs = getVisibleAttributes(className);
                if (attrs.length > 0) {
                    const isSystem = model.docType === 'systems';
                    const w = getBoxWidth(className);
                    const slotInfo = isSystem ? getAttrYCenters(attrs, w, true) : null;
                    const attrsDiv = document.createElement('div');
                    attrsDiv.className = 'attributes';
                    attrs.forEach((attr, idx) => {
                        const line = document.createElement('div');
                        line.className = 'attr-line';
                        const baseType = ConnectionCalculator.extractBaseType(attr.type);

                        if (isSystem) {
                            // System diagrams: wrap flow names, variable slot height, larger font
                            line.style.height = slotInfo.slotHeights[idx] + 'px';
                            line.style.lineHeight = ATTR_LINE_HEIGHT_DEFAULT + 'px';
                            line.style.fontSize = FONT_SIZE_FLOW + 'px';
                            line.style.whiteSpace = 'normal';
                            line.style.display = 'flex';
                            line.style.alignItems = 'center';

                            // Text in a flex child (allows icons on the right)
                            const textSpan = document.createElement('span');
                            textSpan.textContent = attr.name;
                            textSpan.style.flex = '1';
                            textSpan.style.minWidth = '0';
                            if (entityNames.includes(baseType)) {
                                textSpan.style.fontWeight = 'bold';
                            }
                            line.appendChild(textSpan);

                            // Flow icons (format + transport) at right edge
                            if (attr.format || attr.transport) {
                                const iconWrap = document.createElement('span');
                                iconWrap.style.display = 'flex';
                                iconWrap.style.alignItems = 'center';
                                iconWrap.style.gap = '2px';
                                iconWrap.style.marginLeft = '4px';
                                iconWrap.style.flexShrink = '0';
                                if (attr.format) {
                                    const el = FlowIcons.createSVGElement(attr.format);
                                    if (el) iconWrap.appendChild(el);
                                }
                                if (attr.transport) {
                                    const el = FlowIcons.createSVGElement(attr.transport);
                                    if (el) iconWrap.appendChild(el);
                                }
                                if (iconWrap.children.length > 0) {
                                    line.appendChild(iconWrap);
                                }
                            }
                        } else {
                            // DataModel: single-line attributes
                            line.style.lineHeight = ATTR_LINE_HEIGHT + 'px';
                            if (entityNames.includes(baseType)) {
                                line.textContent = attr.name;
                                line.style.fontWeight = 'bold';
                            } else if (ConnectionCalculator.isAggregateType(baseType)) {
                                line.textContent = `«${attr.name}»`;
                            } else {
                                line.textContent = `${attr.name}: ${baseType}`;
                            }
                            // Apply marker styles from schema ui flags
                            if (attr.ui?.readonly) {
                                line.style.color = READONLY_COLOR;
                            }
                            if (attr.ui?.label && !attr.ui?.label2) {
                                line.style.textDecoration = 'underline';
                                line.style.textDecorationStyle = LABEL_UNDERLINE;
                            } else if (attr.ui?.label2) {
                                line.style.textDecoration = 'underline';
                                line.style.textDecorationStyle = LABEL2_UNDERLINE;
                            }
                        }
                        attrsDiv.appendChild(line);
                    });
                    box.appendChild(attrsDiv);
                }
            } else {
                // Compact view: description text
                const description = classDef.description || '';
                if (description) {
                    const descDiv = document.createElement('div');
                    descDiv.className = 'description';
                    descDiv.textContent = description;
                    box.appendChild(descDiv);
                }
            }

            // Drag handling
            makeDraggable(box);

            return box;
        }

        // Make an element draggable
        function makeDraggable(el) {
            let startX, startY, startLeft, startTop;

            el.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; // Only left click

                e.preventDefault();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(el.style.left) || 0;
                startTop = parseInt(el.style.top) || 0;

                el.classList.add('dragging');

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            function onMouseMove(e) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                let newLeft = Math.max(0, startLeft + dx);
                let newTop = Math.max(0, startTop + dy);

                // Snap to grid (10px)
                newLeft = Math.round(newLeft / 10) * 10;
                newTop = Math.round(newTop / 10) * 10;

                el.style.left = newLeft + 'px';
                el.style.top = newTop + 'px';
            }

            function onMouseUp() {
                el.classList.remove('dragging');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);

                // Update layout
                const className = el.dataset.className;
                const newX = parseInt(el.style.left) || 0;
                const newY = parseInt(el.style.top) || 0;

                if (!layout.classes) layout.classes = {};
                const oldPos = layout.classes[className] || {};

                if (oldPos.x !== newX || oldPos.y !== newY) {
                    layout.classes[className] = { x: newX, y: newY };
                    isDirty = true;
                    statusEl.textContent = 'Unsaved changes';

                    // Re-render to update connections and auto-size canvas
                    renderCanvas();
                }
            }
        }

        // Save layout and diagrams
        async function saveLayout() {
            if (!currentDoc || !layout) return;

            statusEl.textContent = 'Saving...';
            try {
                // Generate both SVGs client-side
                const svgCompact = generateSVG(false);
                const svgDetailed = generateSVG(true);

                // Save everything in one request
                const response = await fetch('api/layout-editor/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        doc: currentDoc,
                        layout: layout,
                        svgCompact: svgCompact,
                        svgDetailed: svgDetailed,
                        model: model  // For PDF cards generation
                    })
                });
                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Save failed');
                }

                isDirty = false;
                statusEl.textContent = 'Saved!';
                setTimeout(() => {
                    if (!isDirty) statusEl.textContent = '';
                }, 2000);
            } catch (e) {
                console.error('Save failed:', e);
                statusEl.textContent = 'Error: ' + e.message;
            }
        }

        // Toggle detailed view mode
        function toggleDetailedView() {
            showDetailed = !showDetailed;
            viewLayoutBtn.classList.toggle('active', showDetailed);
            renderCanvas();
        }

        // Event listeners
        docSelect.addEventListener('change', () => loadDocument(docSelect.value));
        saveBtn.addEventListener('click', saveLayout);
        reloadModelBtn.addEventListener('click', reloadModel);
        viewLayoutBtn.addEventListener('click', toggleDetailedView);

        // Fit to content toggle
        const fitToContentCheckbox = document.getElementById('fitToContent');
        fitToContentCheckbox.addEventListener('change', () => {
            fitToContent = fitToContentCheckbox.checked;
            renderCanvas();
        });

        // Warn on unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (isDirty) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // Load app config for title
        async function loadAppConfig() {
            try {
                const res = await fetch('api/app/config');
                if (res.ok) {
                    const config = await res.json();
                    const appName = config.app_name || 'AIDE RAP';
                    document.getElementById('pageTitle').textContent = appName + ' - Layout Editor';
                    document.title = 'Layout Editor - ' + appName;
                }
            } catch (e) {
                console.warn('Could not load app config:', e);
            }
        }

        // Initialize
        loadAppConfig();
        loadDocuments();
    </script>
</body>
</html>
