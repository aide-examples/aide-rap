<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layout Editor - AIDE RAP</title>
    <link rel="stylesheet" href="/static/rap/diagram/layout-editor.css">
</head>
<body>
    <div class="toolbar">
        <h1 id="pageTitle">Layout Editor</h1>
        <label>Document:
            <select id="docSelect">
                <option value="">Loading...</option>
            </select>
        </label>
        <button id="viewLayout" class="secondary active">Layout</button>
        <label class="toggle-label">
            <input type="checkbox" id="fitToContent" checked>
            <span>Fit to content</span>
        </label>
        <div class="spacer"></div>
        <span class="help-text">Drag boxes to reposition</span>
        <a id="linkCompact" href="#" target="_blank" style="color: #aaa; font-size: 12px; display: none;">Compact</a>
        <a id="linkDetailed" href="#" target="_blank" style="color: #aaa; font-size: 12px; display: none;">Detailed</a>
        <a id="linkCardsPdf" href="#" target="_blank" style="color: #aaa; font-size: 12px; display: none;">Cards.pdf</a>
        <a id="linkCardsDocx" href="#" target="_blank" style="color: #aaa; font-size: 12px; display: none;">Cards.docx</a>
        <button id="saveBtn">Save</button>
        <button id="reloadModelBtn" class="secondary" style="display: none;">↻ Reload Model</button>
        <span class="status" id="status"></span>
        <a href="/" class="back-link" id="backLink">BACK</a>
    </div>
    <div class="canvas-container">
        <div class="canvas" id="canvas">
            <div class="loading">Select a document to edit its layout</div>
        </div>
    </div>

    <!-- Diagram modules -->
    <script src="/static/rap/diagram/DiagramConstants.js"></script>
    <script src="/static/rap/diagram/ConnectionCalculator.js"></script>

    <script>
        // Create local references to shared modules (loaded via <script> tags above)
        const DiagramConstants = window.DiagramConstants;
        const ConnectionCalculator = window.ConnectionCalculator;

        // Import constants from shared module
        const { BOX_WIDTH, BOX_HEIGHT_COMPACT, ATTR_LINE_HEIGHT, HEADER_HEIGHT, BOX_PADDING,
                STROKE_COLOR, STROKE_WIDTH, FONT_FAMILY, FONT_SIZE_CLASS, FONT_SIZE_ATTR, FONT_SIZE_LABEL,
                OPTIONAL_DASH, READONLY_DASH } = DiagramConstants;

        /**
         * Escape text for use in XML/SVG.
         */
        function escapeXml(text) {
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        let currentDoc = null;
        let model = null;
        let layout = null;
        let showDetailed = true;
        let isDirty = false;
        let fitToContent = true;

        // Canvas for text measurement
        const measureCanvas = document.createElement('canvas');
        const measureCtx = measureCanvas.getContext('2d');

        // Measure text width using canvas
        function measureText(text, fontSize, fontFamily) {
            measureCtx.font = `${fontSize}px ${fontFamily}`;
            return measureCtx.measureText(text).width;
        }

        // Truncate text to fit within maxWidth, adding ellipsis if needed
        function truncateText(text, maxWidth, fontSize, fontFamily) {
            const textWidth = measureText(text, fontSize, fontFamily);
            if (textWidth <= maxWidth) return text;

            const ellipsis = '...';
            const ellipsisWidth = measureText(ellipsis, fontSize, fontFamily);
            const availableWidth = maxWidth - ellipsisWidth;

            // Binary search for max characters that fit
            let lo = 0, hi = text.length;
            while (hi - lo > 1) {
                const mid = Math.floor((lo + hi) / 2);
                if (measureText(text.substring(0, mid), fontSize, fontFamily) <= availableWidth) {
                    lo = mid;
                } else {
                    hi = mid;
                }
            }
            return text.substring(0, lo) + ellipsis;
        }

        // Word-wrap text into lines that fit within maxWidth
        function wrapText(text, maxWidth, fontSize, fontFamily) {
            const words = text.split(/\s+/).filter(Boolean);
            if (words.length === 0) return [];
            const lines = [];
            let currentLine = words[0];
            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' ' + words[i];
                if (measureText(testLine, fontSize, fontFamily) > maxWidth) {
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // Calculate box width based on content
        function getBoxWidth(className) {
            const classDef = model.classes[className] || {};
            const nameWidth = measureText(className, FONT_SIZE_CLASS, FONT_FAMILY) + 20;
            const entityNames = Object.keys(model.classes);

            // Calculate what detailed mode width would be
            function calcDetailedWidth() {
                if (!fitToContent) return BOX_WIDTH;
                const attrs = getVisibleAttributes(className);
                let maxWidth = measureText(className, FONT_SIZE_CLASS, FONT_FAMILY);
                for (const attr of attrs) {
                    const cleanType = ConnectionCalculator.extractBaseType(attr.type);
                    const attrText = entityNames.includes(cleanType)
                        ? attr.name
                        : `${attr.name}: ${cleanType}`;
                    maxWidth = Math.max(maxWidth, measureText(attrText, FONT_SIZE_ATTR, FONT_FAMILY));
                }
                return Math.max(BOX_WIDTH * 0.6, maxWidth + 20);
            }

            if (showDetailed) {
                return calcDetailedWidth();
            }

            // Compact mode: at least as wide as detailed view
            const minWidth = calcDetailedWidth();
            const description = classDef.description || '';
            if (!description) return Math.max(nameWidth, minWidth);

            const h = getBoxHeight(className);
            const availableHeight = h - HEADER_HEIGHT - BOX_PADDING;
            const maxLines = Math.max(1, Math.floor(availableHeight / ATTR_LINE_HEIGHT));
            const textPadding = 20; // matches CSS: 8px padding * 2 + 1.5px border * 2

            // Binary search for minimum width where description fits in maxLines
            let lo = nameWidth;
            let hi = 300;

            const linesAtMax = wrapText(description, hi - textPadding, FONT_SIZE_ATTR, FONT_FAMILY);
            if (linesAtMax.length > maxLines) return Math.max(hi, minWidth);

            while (hi - lo > 2) {
                const mid = Math.floor((lo + hi) / 2);
                const lines = wrapText(description, mid - textPadding, FONT_SIZE_ATTR, FONT_FAMILY);
                if (lines.length <= maxLines) {
                    hi = mid;
                } else {
                    lo = mid;
                }
            }

            return Math.max(nameWidth, hi, minWidth);
        }

        // DOM elements
        const docSelect = document.getElementById('docSelect');
        const canvas = document.getElementById('canvas');
        const saveBtn = document.getElementById('saveBtn');
        const reloadModelBtn = document.getElementById('reloadModelBtn');
        const statusEl = document.getElementById('status');
        const viewLayoutBtn = document.getElementById('viewLayout');
        const linkCompact = document.getElementById('linkCompact');
        const linkDetailed = document.getElementById('linkDetailed');
        const linkCardsPdf = document.getElementById('linkCardsPdf');
        const linkCardsDocx = document.getElementById('linkCardsDocx');

        // Calculate box height based on visible attributes (same for compact and detailed)
        function getBoxHeight(className) {
            const attrs = getVisibleAttributes(className);
            return HEADER_HEIGHT + attrs.length * ATTR_LINE_HEIGHT + BOX_PADDING;
        }

        // Get area color for a class
        function getColor(className) {
            const classDef = model.classes[className] || {};
            const area = classDef.area || '';
            const areaDef = model.areas[area] || {};
            return areaDef.color || '#FFFFFF';
        }

        // Get visible attributes, reordered with self-references first
        function getVisibleAttributes(className) {
            const classDef = model.classes[className] || {};
            return ConnectionCalculator.getVisibleAttributes(classDef.attributes, className);
        }

        // Load available documents
        async function loadDocuments() {
            try {
                const response = await fetch('/api/layout-editor/documents');
                const docs = await response.json();
                docSelect.innerHTML = '<option value="">-- Select --</option>';
                docs.forEach(doc => {
                    const option = document.createElement('option');
                    option.value = doc;
                    option.textContent = doc;
                    docSelect.appendChild(option);
                });

                // Check URL parameter or auto-load if only one document
                const urlParams = new URLSearchParams(window.location.search);
                const docParam = urlParams.get('doc');
                if (docParam && docs.includes(docParam)) {
                    docSelect.value = docParam;
                    loadDocument(docParam);
                } else if (docs.length === 1) {
                    // Auto-load if only one document available
                    docSelect.value = docs[0];
                    loadDocument(docs[0]);
                }
            } catch (e) {
                console.error('Failed to load documents:', e);
                docSelect.innerHTML = '<option value="">Error loading</option>';
            }
        }

        // Load document model and layout
        async function loadDocument(docName) {
            if (!docName) {
                canvas.innerHTML = '<div class="loading">Select a document to edit its layout</div>';
                return;
            }

            canvas.innerHTML = '<div class="loading">Loading...</div>';
            statusEl.textContent = '';

            try {
                const response = await fetch(`/api/layout-editor/load?doc=${encodeURIComponent(docName)}`);
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to load');
                }

                currentDoc = docName;
                model = data.model;
                layout = data.layout;
                isDirty = false;


                // Update diagram links
                linkCompact.href = `/docs-assets/requirements/${docName}-diagram.svg`;
                linkDetailed.href = `/docs-assets/requirements/${docName}-diagram-detailed.svg`;
                linkCardsPdf.href = `/docs-assets/requirements/EntityCards.pdf`;
                linkCardsDocx.href = `/docs-assets/requirements/EntityCards.docx`;
                linkCompact.style.display = 'inline';
                linkDetailed.style.display = 'inline';
                linkCardsPdf.style.display = 'inline';
                linkCardsDocx.style.display = 'inline';

                renderCanvas();

                // Check for model changes after loading
                await checkForModelChanges();
            } catch (e) {
                console.error('Failed to load document:', e);
                canvas.innerHTML = `<div class="loading">Error: ${e.message}</div>`;
            }
        }

        /**
         * Check if the data model has changed since server startup.
         * Shows a dialog if changes are detected.
         */
        async function checkForModelChanges() {
            try {
                const resp = await fetch('/api/schema/check-changes');
                const { changed } = await resp.json();

                if (changed) {
                    // Show reload button
                    reloadModelBtn.style.display = 'inline-block';
                    reloadModelBtn.classList.add('highlight');

                    // Alert user
                    const reload = confirm(
                        'Das Datenmodell hat sich geändert.\n\n' +
                        'Möchten Sie das Modell neu laden?\n' +
                        '(Alternativ: "↻ Reload Model" Button verwenden)'
                    );

                    if (reload) {
                        await reloadModel();
                    }
                } else {
                    reloadModelBtn.style.display = 'none';
                }
            } catch (e) {
                console.warn('Could not check for model changes:', e);
            }
        }

        /**
         * Reload the schema from markdown files and refresh the editor.
         */
        async function reloadModel() {
            statusEl.textContent = 'Reloading model...';
            try {
                const resp = await fetch('/api/schema/reload', { method: 'POST' });
                const result = await resp.json();

                if (!result.success) {
                    throw new Error(result.error || 'Reload failed');
                }

                // Reload current document to get fresh model
                if (currentDoc) {
                    await loadDocument(currentDoc);
                }

                reloadModelBtn.style.display = 'none';
                reloadModelBtn.classList.remove('highlight');
                statusEl.textContent = 'Model reloaded';
                setTimeout(() => { if (!isDirty) statusEl.textContent = ''; }, 2000);
            } catch (e) {
                console.error('Model reload failed:', e);
                statusEl.textContent = 'Error: ' + e.message;
            }
        }

        // Render all class boxes on canvas
        function renderCanvas() {
            if (!model || !layout) return;

            const positions = layout.classes || {};

            // Calculate canvas size to fit all entities
            let maxX = 400;
            let maxY = 300;

            for (const className of Object.keys(model.classes)) {
                const pos = positions[className] || { x: 50, y: 50 };
                const height = getBoxHeight(className);
                const width = getBoxWidth(className);
                maxX = Math.max(maxX, pos.x + width + 50);
                maxY = Math.max(maxY, pos.y + height + 50);
            }

            // Update layout canvas size
            if (!layout.canvas) layout.canvas = {};
            layout.canvas.width = maxX;
            layout.canvas.height = maxY;

            canvas.style.width = maxX + 'px';
            canvas.style.height = maxY + 'px';
            canvas.innerHTML = '';

            // Create SVG layer for connections
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('connections-layer');
            svg.setAttribute('width', maxX);
            svg.setAttribute('height', maxY);
            canvas.appendChild(svg);

            // Create class boxes
            for (const [className, classDef] of Object.entries(model.classes)) {
                const pos = positions[className] || { x: 50, y: 50 };
                const box = createClassBox(className, classDef, pos);
                canvas.appendChild(box);
            }

            // Draw connection lines
            drawConnections(svg, positions);
        }

        // Get connection points for a relationship (using shared module)
        function getConnectionPoint(fromClass, toClass, attrIndex, positions) {
            const fromPos = positions[fromClass] || { x: 50, y: 50 };
            const toPos = positions[toClass] || { x: 50, y: 50 };
            const fromHeight = getBoxHeight(fromClass);
            const toHeight = getBoxHeight(toClass);
            const fromWidth = getBoxWidth(fromClass);
            const toWidth = getBoxWidth(toClass);

            return ConnectionCalculator.getConnectionPoint(
                fromPos, toPos, fromHeight, toHeight, attrIndex, showDetailed, fromWidth, toWidth
            );
        }

        // Draw lines between related entities
        function drawConnections(svg, positions) {
            if (!model || !model.classes) return;

            // Add arrowhead marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
                </marker>
            `;
            svg.appendChild(defs);

            const entityNames = Object.keys(model.classes);

            for (const className of Object.keys(model.classes)) {
                const attrs = getVisibleAttributes(className);

                for (let i = 0; i < attrs.length; i++) {
                    const attr = attrs[i];
                    const baseType = ConnectionCalculator.extractBaseType(attr.type);

                    if (entityNames.includes(baseType)) {
                        const fromPos = positions[className] || { x: 50, y: 50 };
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke', DiagramConstants.STROKE_COLOR);
                        path.setAttribute('stroke-width', '1');
                        path.setAttribute('marker-end', 'url(#arrowhead)');

                        // Dashed/dotted line for optional or readonly relationships
                        if (/\[READONLY\]/i.test(attr.description || '')) {
                            path.setAttribute('stroke-dasharray', READONLY_DASH);
                        } else if (/\[OPTIONAL\]/i.test(attr.type)) {
                            path.setAttribute('stroke-dasharray', OPTIONAL_DASH);
                        }

                        let pathD;

                        if (className === baseType) {
                            // Self-reference semicircle
                            const boxWidth = getBoxWidth(className);
                            const bHeight = getBoxHeight(className);
                            const arc = ConnectionCalculator.getSelfReferenceArc(fromPos, boxWidth, bHeight);
                            pathD = ConnectionCalculator.getSelfReferenceArcPath(arc);
                        } else {
                            // Normal connection
                            const conn = getConnectionPoint(className, baseType, i, positions);
                            pathD = ConnectionCalculator.getNormalConnectionPath(conn);
                        }

                        path.setAttribute('d', pathD);
                        svg.appendChild(path);
                    }
                }
            }
        }

        /**
         * Generate complete SVG string for export.
         * @param {boolean} detailed - Whether to show attributes
         * @returns {string} Complete SVG document
         */
        function generateSVG(detailed) {
            if (!model || !layout) return '';

            const positions = layout.classes || {};
            const entityNames = Object.keys(model.classes);

            // Helper to get box height for a class (always attribute-based)
            function boxHeight(className) {
                const attrs = ConnectionCalculator.getVisibleAttributes(
                    (model.classes[className] || {}).attributes, className
                );
                return HEADER_HEIGHT + attrs.length * ATTR_LINE_HEIGHT + BOX_PADDING;
            }

            // Helper to get box width for a class (matches getBoxWidth logic)
            function boxWidth(className) {
                const classDef = model.classes[className] || {};
                const nameWidth = measureText(className, FONT_SIZE_CLASS, FONT_FAMILY) + 20;

                // Calculate detailed mode width
                function calcDetailedWidth() {
                    if (!fitToContent) return BOX_WIDTH;
                    const attrs = ConnectionCalculator.getVisibleAttributes(
                        (model.classes[className] || {}).attributes, className
                    );
                    let maxWidth = measureText(className, FONT_SIZE_CLASS, FONT_FAMILY);
                    for (const attr of attrs) {
                        const cleanType = ConnectionCalculator.extractBaseType(attr.type);
                        const attrText = entityNames.includes(cleanType)
                            ? attr.name
                            : `${attr.name}: ${cleanType}`;
                        maxWidth = Math.max(maxWidth, measureText(attrText, FONT_SIZE_ATTR, FONT_FAMILY));
                    }
                    return Math.max(BOX_WIDTH * 0.6, maxWidth + 20);
                }

                if (detailed) {
                    return calcDetailedWidth();
                }

                // Compact mode: at least as wide as detailed view
                const minWidth = calcDetailedWidth();
                const description = classDef.description || '';
                if (!description) return Math.max(nameWidth, minWidth);

                const h = boxHeight(className);
                const availableHeight = h - HEADER_HEIGHT - BOX_PADDING;
                const maxLines = Math.max(1, Math.floor(availableHeight / ATTR_LINE_HEIGHT));
                const textPadding = 20;

                let lo = nameWidth;
                let hi = 300;

                const linesAtMax = wrapText(description, hi - textPadding, FONT_SIZE_ATTR, FONT_FAMILY);
                if (linesAtMax.length > maxLines) return Math.max(hi, minWidth);

                while (hi - lo > 2) {
                    const mid = Math.floor((lo + hi) / 2);
                    const lines = wrapText(description, mid - textPadding, FONT_SIZE_ATTR, FONT_FAMILY);
                    if (lines.length <= maxLines) {
                        hi = mid;
                    } else {
                        lo = mid;
                    }
                }

                return Math.max(nameWidth, hi, minWidth);
            }

            // Pre-compute widths for all entities
            const widths = {};
            for (const className of entityNames) {
                widths[className] = boxWidth(className);
            }

            // Calculate canvas dimensions
            let maxX = 400, entitiesMaxY = 0;
            for (const className of entityNames) {
                const pos = positions[className] || { x: 50, y: 50 };
                maxX = Math.max(maxX, pos.x + widths[className] + 50);
                entitiesMaxY = Math.max(entitiesMaxY, pos.y + boxHeight(className));
            }

            // Calculate legend height (areas + possibly global types + header + padding)
            const numAreas = Object.keys(model.areas || {}).length;
            const hasGlobalTypes = Object.keys(model.globalTypes || {}).length > 0;
            const legendRows = numAreas + (hasGlobalTypes ? 1 : 0);
            const legendHeight = 30 + legendRows * 20 + 20; // header + rows + bottom padding

            const width = maxX;
            const height = entitiesMaxY + 40 + legendHeight; // 40px gap between entities and legend

            const parts = [
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">`,
                '  <defs>',
                '    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">',
                '      <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>',
                '    </marker>'
            ];

            // ClipPath defs for compact mode (header background clipping)
            if (!detailed) {
                for (const className of entityNames) {
                    if (!(className in positions)) continue;
                    const pos = positions[className];
                    const h = boxHeight(className);
                    const w = widths[className];
                    parts.push(`    <clipPath id="clip-${escapeXml(className)}"><rect x="${pos.x}" y="${pos.y}" width="${w}" height="${h}" rx="3"/></clipPath>`);
                }
            }

            parts.push('  </defs>');
            parts.push(`  <rect width="${width}" height="${height}" fill="white"/>`);
            parts.push('');
            parts.push('  <!-- Relationships -->');

            // Render relationships
            for (const className of entityNames) {
                const attrs = ConnectionCalculator.getVisibleAttributes(
                    (model.classes[className] || {}).attributes, className
                );
                const fromPos = positions[className] || { x: 50, y: 50 };

                for (let i = 0; i < attrs.length; i++) {
                    const attr = attrs[i];
                    const baseType = ConnectionCalculator.extractBaseType(attr.type);

                    if (entityNames.includes(baseType)) {
                        const isOptional = /\[OPTIONAL\]/i.test(attr.type);
                        const isReadonly = /\[READONLY\]/i.test(attr.description || '');
                        const dashAttr = isReadonly
                            ? ` stroke-dasharray="${READONLY_DASH}"`
                            : (isOptional ? ` stroke-dasharray="${OPTIONAL_DASH}"` : '');

                        if (className === baseType) {
                            // Self-reference semicircle
                            const arc = ConnectionCalculator.getSelfReferenceArc(fromPos, widths[className], boxHeight(className));
                            const pathD = ConnectionCalculator.getSelfReferenceArcPath(arc);

                            parts.push(`  <path d="${pathD}" fill="none" stroke="${STROKE_COLOR}" stroke-width="1" marker-end="url(#arrowhead)"${dashAttr}/>`);
                        } else {
                            // Normal connection
                            const toPos = positions[baseType] || { x: 50, y: 50 };
                            const fromHeight = boxHeight(className);
                            const toHeight = boxHeight(baseType);
                            const conn = ConnectionCalculator.getConnectionPoint(
                                fromPos, toPos, fromHeight, toHeight, i, detailed,
                                widths[className], widths[baseType]
                            );
                            const pathD = ConnectionCalculator.getNormalConnectionPath(conn);

                            parts.push(`  <path d="${pathD}" fill="none" stroke="${STROKE_COLOR}" stroke-width="1" marker-end="url(#arrowhead)"${dashAttr}/>`);
                        }
                    }
                }
            }

            parts.push('');
            parts.push('  <!-- Class boxes -->');

            // Render class boxes
            for (const className of entityNames) {
                if (!(className in positions)) continue;

                const pos = positions[className];
                const classDef = model.classes[className] || {};
                const color = getColor(className);
                const h = boxHeight(className);
                const w = widths[className];

                if (detailed) {
                    // Detailed mode: full area color background
                    parts.push(`  <rect x="${pos.x}" y="${pos.y}" width="${w}" height="${h}" fill="${color}" stroke="${STROKE_COLOR}" stroke-width="${STROKE_WIDTH}" rx="3"/>`);
                } else {
                    // Compact mode: white body + colored header (clipped to rounded box)
                    parts.push(`  <rect x="${pos.x}" y="${pos.y}" width="${w}" height="${h}" fill="white" stroke="${STROKE_COLOR}" stroke-width="${STROKE_WIDTH}" rx="3"/>`);
                    parts.push(`  <rect x="${pos.x}" y="${pos.y}" width="${w}" height="${HEADER_HEIGHT}" fill="${color}" clip-path="url(#clip-${escapeXml(className)})"/>`);
                }

                // Class name (centered in header)
                const textY = pos.y + HEADER_HEIGHT / 2 + 4;
                parts.push(`  <text x="${pos.x + w / 2}" y="${textY}" text-anchor="middle" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_CLASS}" font-weight="bold">${escapeXml(className)}</text>`);

                // Separator line
                const sepY = pos.y + HEADER_HEIGHT;
                parts.push(`  <line x1="${pos.x}" y1="${sepY}" x2="${pos.x + w}" y2="${sepY}" stroke="${STROKE_COLOR}" stroke-width="1"/>`);

                if (detailed) {
                    // Detailed mode: attributes (FK attrs as bold name, others as name: type)
                    const visibleAttrs = ConnectionCalculator.getVisibleAttributes(classDef.attributes, className);
                    const maxTextWidth = w - 10; // 5px padding on each side
                    for (let i = 0; i < visibleAttrs.length; i++) {
                        const attr = visibleAttrs[i];
                        const attrY = sepY + (i + 1) * ATTR_LINE_HEIGHT - 2;
                        const cleanType = ConnectionCalculator.extractBaseType(attr.type);
                        if (entityNames.includes(cleanType)) {
                            // FK attribute: bold name only
                            const displayText = fitToContent ? attr.name : truncateText(attr.name, maxTextWidth, FONT_SIZE_ATTR, FONT_FAMILY);
                            parts.push(`  <text x="${pos.x + 5}" y="${attrY}" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_ATTR}" font-weight="bold">${escapeXml(displayText)}</text>`);
                        } else {
                            const fullText = `${attr.name}: ${cleanType}`;
                            const displayText = fitToContent ? fullText : truncateText(fullText, maxTextWidth, FONT_SIZE_ATTR, FONT_FAMILY);
                            parts.push(`  <text x="${pos.x + 5}" y="${attrY}" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_ATTR}">${escapeXml(displayText)}</text>`);
                        }
                    }
                } else {
                    // Compact mode: word-wrapped description text
                    const description = classDef.description || '';
                    if (description) {
                        const textPadding = 5;
                        const lines = wrapText(description, w - textPadding * 2, FONT_SIZE_ATTR, FONT_FAMILY);
                        const availableLines = Math.max(1, Math.floor((h - HEADER_HEIGHT - BOX_PADDING) / ATTR_LINE_HEIGHT));
                        const displayLines = lines.slice(0, availableLines);

                        for (let i = 0; i < displayLines.length; i++) {
                            const lineY = sepY + (i + 1) * ATTR_LINE_HEIGHT - 2;
                            parts.push(`  <text x="${pos.x + textPadding}" y="${lineY}" font-family="${FONT_FAMILY}" font-size="${FONT_SIZE_ATTR}" fill="#555">${escapeXml(displayLines[i])}</text>`);
                        }
                    }
                }
            }

            // Legend
            parts.push('');
            parts.push('  <!-- Legend -->');

            // Collect types by area
            const typesByArea = {};
            for (const [className, classDef] of Object.entries(model.classes || {})) {
                if (classDef.types && Object.keys(classDef.types).length > 0) {
                    const area = classDef.area || 'unknown';
                    if (!typesByArea[area]) typesByArea[area] = [];
                    for (const typeName of Object.keys(classDef.types)) {
                        typesByArea[area].push(typeName);
                    }
                }
            }

            // Global types (gray)
            const globalTypeNames = Object.keys(model.globalTypes || {});

            let legendX = 20;
            let legendY = entitiesMaxY + 50; // Start below entity area with gap
            const typesStartX = 160; // Start X for types column
            const typeBoxWidth = 10;
            const typeBoxHeight = 10;
            const typeSpacing = 5;

            parts.push(`  <text x="${legendX}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="12" font-weight="bold">Areas:</text>`);
            parts.push(`  <text x="${typesStartX}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="12" font-weight="bold">Types:</text>`);
            legendY += 20;

            for (const [areaId, areaDef] of Object.entries(model.areas || {})) {
                const areaColor = areaDef.color || '#FFFFFF';
                const areaName = areaDef.name || areaId;

                // Area box and name
                parts.push(`  <rect x="${legendX}" y="${legendY - 10}" width="14" height="14" fill="${areaColor}" stroke="${STROKE_COLOR}" stroke-width="1"/>`);
                parts.push(`  <text x="${legendX + 20}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="11">${escapeXml(areaName)}</text>`);

                // Types for this area (on the same row)
                const areaTypes = typesByArea[areaId] || [];
                let typeX = typesStartX;
                for (const typeName of areaTypes) {
                    const textWidth = measureText(typeName, 9, FONT_FAMILY);
                    parts.push(`  <rect x="${typeX}" y="${legendY - 9}" width="${textWidth + 6}" height="${typeBoxHeight + 2}" fill="${areaColor}" stroke="${STROKE_COLOR}" stroke-width="0.5" rx="2"/>`);
                    parts.push(`  <text x="${typeX + 3}" y="${legendY - 1}" font-family="${FONT_FAMILY}" font-size="9">${escapeXml(typeName)}</text>`);
                    typeX += textWidth + 6 + typeSpacing;
                }

                legendY += 20;
            }

            // Global types row (gray)
            if (globalTypeNames.length > 0) {
                const grayColor = '#E0E0E0';
                parts.push(`  <rect x="${legendX}" y="${legendY - 10}" width="14" height="14" fill="${grayColor}" stroke="${STROKE_COLOR}" stroke-width="1"/>`);
                parts.push(`  <text x="${legendX + 20}" y="${legendY}" font-family="${FONT_FAMILY}" font-size="11">Global</text>`);

                let typeX = typesStartX;
                for (const typeName of globalTypeNames) {
                    const textWidth = measureText(typeName, 9, FONT_FAMILY);
                    parts.push(`  <rect x="${typeX}" y="${legendY - 9}" width="${textWidth + 6}" height="${typeBoxHeight + 2}" fill="${grayColor}" stroke="${STROKE_COLOR}" stroke-width="0.5" rx="2"/>`);
                    parts.push(`  <text x="${typeX + 3}" y="${legendY - 1}" font-family="${FONT_FAMILY}" font-size="9">${escapeXml(typeName)}</text>`);
                    typeX += textWidth + 6 + typeSpacing;
                }
            }

            // Watermark in bottom right corner (aligned with legend start)
            parts.push('');
            parts.push('  <!-- Watermark -->');
            const wmX = width - 15;
            const wmYBase = entitiesMaxY + 50; // Same as legend start
            const today = new Date().toLocaleDateString('de-DE', { year: 'numeric', month: 'long', day: 'numeric' });
            parts.push(`  <text x="${wmX}" y="${wmYBase}" text-anchor="end" font-family="${FONT_FAMILY}" font-size="11" fill="#555">Artificial Intelligence for Development Engineers <tspan fill="#0066cc">(http://github.com/aide-examples)</tspan></text>`);
            parts.push(`  <text x="${wmX}" y="${wmYBase + 14}" text-anchor="end" font-family="${FONT_FAMILY}" font-size="11" fill="#555">Rapid Application Prototype</text>`);
            parts.push(`  <text x="${wmX}" y="${wmYBase + 28}" text-anchor="end" font-family="${FONT_FAMILY}" font-size="11" fill="#555">IRMA : Intelligent Repair and Maintenance in Aviation</text>`);
            parts.push(`  <text x="${wmX}" y="${wmYBase + 42}" text-anchor="end" font-family="${FONT_FAMILY}" font-size="11" fill="#555">Frankfurt, ${today}</text>`);

            parts.push('</svg>');
            return parts.join('\n');
        }

        // Create a draggable class box element
        function createClassBox(className, classDef, pos) {
            const entityNames = Object.keys(model.classes);
            const box = document.createElement('div');
            box.className = 'class-box' + (showDetailed ? '' : ' compact') + (fitToContent ? ' fit-content' : '');
            box.dataset.className = className;
            box.style.left = pos.x + 'px';
            box.style.top = pos.y + 'px';
            box.style.height = getBoxHeight(className) + 'px';
            box.style.width = getBoxWidth(className) + 'px';

            if (showDetailed) {
                // Detailed mode: full area color background
                box.style.backgroundColor = getColor(className);
            }

            // Header
            const header = document.createElement('div');
            header.className = 'header';
            header.textContent = className;
            if (!showDetailed) {
                // Compact mode: only header has area color
                header.style.backgroundColor = getColor(className);
            }
            box.appendChild(header);

            if (showDetailed) {
                // Detailed view: attributes (FK attrs shown as bold name only)
                const attrs = getVisibleAttributes(className);
                if (attrs.length > 0) {
                    const attrsDiv = document.createElement('div');
                    attrsDiv.className = 'attributes';
                    attrs.forEach(attr => {
                        const line = document.createElement('div');
                        line.className = 'attr-line';
                        const baseType = ConnectionCalculator.extractBaseType(attr.type);
                        if (entityNames.includes(baseType)) {
                            // FK attribute: bold name only
                            line.textContent = attr.name;
                            line.style.fontWeight = 'bold';
                        } else {
                            line.textContent = `${attr.name}: ${baseType}`;
                        }
                        attrsDiv.appendChild(line);
                    });
                    box.appendChild(attrsDiv);
                }
            } else {
                // Compact view: description text
                const description = classDef.description || '';
                if (description) {
                    const descDiv = document.createElement('div');
                    descDiv.className = 'description';
                    descDiv.textContent = description;
                    box.appendChild(descDiv);
                }
            }

            // Drag handling
            makeDraggable(box);

            return box;
        }

        // Make an element draggable
        function makeDraggable(el) {
            let startX, startY, startLeft, startTop;

            el.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; // Only left click

                e.preventDefault();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(el.style.left) || 0;
                startTop = parseInt(el.style.top) || 0;

                el.classList.add('dragging');

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            function onMouseMove(e) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                let newLeft = Math.max(0, startLeft + dx);
                let newTop = Math.max(0, startTop + dy);

                // Snap to grid (10px)
                newLeft = Math.round(newLeft / 10) * 10;
                newTop = Math.round(newTop / 10) * 10;

                el.style.left = newLeft + 'px';
                el.style.top = newTop + 'px';
            }

            function onMouseUp() {
                el.classList.remove('dragging');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);

                // Update layout
                const className = el.dataset.className;
                const newX = parseInt(el.style.left) || 0;
                const newY = parseInt(el.style.top) || 0;

                if (!layout.classes) layout.classes = {};
                const oldPos = layout.classes[className] || {};

                if (oldPos.x !== newX || oldPos.y !== newY) {
                    layout.classes[className] = { x: newX, y: newY };
                    isDirty = true;
                    statusEl.textContent = 'Unsaved changes';

                    // Re-render to update connections and auto-size canvas
                    renderCanvas();
                }
            }
        }

        // Save layout and diagrams
        async function saveLayout() {
            if (!currentDoc || !layout) return;

            statusEl.textContent = 'Saving...';
            try {
                // Generate both SVGs client-side
                const svgCompact = generateSVG(false);
                const svgDetailed = generateSVG(true);

                // Save everything in one request
                const response = await fetch('/api/layout-editor/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        doc: currentDoc,
                        layout: layout,
                        svgCompact: svgCompact,
                        svgDetailed: svgDetailed,
                        model: model  // For PDF cards generation
                    })
                });
                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Save failed');
                }

                isDirty = false;
                statusEl.textContent = 'Saved!';
                setTimeout(() => {
                    if (!isDirty) statusEl.textContent = '';
                }, 2000);
            } catch (e) {
                console.error('Save failed:', e);
                statusEl.textContent = 'Error: ' + e.message;
            }
        }

        // Toggle detailed view mode
        function toggleDetailedView() {
            showDetailed = !showDetailed;
            viewLayoutBtn.classList.toggle('active', showDetailed);
            renderCanvas();
        }

        // Event listeners
        docSelect.addEventListener('change', () => loadDocument(docSelect.value));
        saveBtn.addEventListener('click', saveLayout);
        reloadModelBtn.addEventListener('click', reloadModel);
        viewLayoutBtn.addEventListener('click', toggleDetailedView);

        // Fit to content toggle
        const fitToContentCheckbox = document.getElementById('fitToContent');
        fitToContentCheckbox.addEventListener('change', () => {
            fitToContent = fitToContentCheckbox.checked;
            renderCanvas();
        });

        // Warn on unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (isDirty) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // Load app config for title
        async function loadAppConfig() {
            try {
                const res = await fetch('/api/app/config');
                if (res.ok) {
                    const config = await res.json();
                    const appName = config.app_name || 'AIDE RAP';
                    document.getElementById('pageTitle').textContent = appName + ' - Layout Editor';
                    document.title = 'Layout Editor - ' + appName;
                }
            } catch (e) {
                console.warn('Could not load app config:', e);
            }
        }

        // Initialize
        loadAppConfig();
        loadDocuments();
    </script>
</body>
</html>
